---
title: "Temple Tower Project"
format: html
---

First I'm going to load some packages. Tidyverse has most of the functions I use for msot data analysis, plus a bunch of packages I probably won't use but it's fine for now.

```{r}
library("tidyverse")
library("readr")
```

Now I'm going to load in the data for the tower. This is in the below format.

```{r}
tower_data <- read_csv("tower_data.csv") 
head(tower_data,20)
sides <- 1:4
rows <- 1:6
space <- tower_data$Space %>% unique()
```

Let's add a check that the whole tower adds to 365 like its supposed to

```{r}
sum(tower_data$Value) %>%
    print()
```

Next I'm going to make a few functions to help analyze the tower data. The first one is a helper function called "wrap around" which helps so that if I rotate a level of the tower past side 4 it is on side 1, rather than a mythical side 5.

```{r}

wrap_around <- function(x) {
  ifelse(x > 4, x - 4, x)
}

```

The next few functions are for getting the sums of each column in a given configuration. The alignment of the tower is given as the "alignment matrix". The first function will rotate the tower to match a given alignment and sum up each row. Then there are tests to check if the left and right columns sum to 30 and the middle column sums to 31.

Finally, a big "configuration test" function will combine all those and spit out a single dataframe.

```{r}

side_sums <- function(alignment_matrix_to_test = c(rep(1, 6), rep(1, 6)), data = tower_data){
    
    # Convert to vector if needed
    align_vec <- unlist(alignment_matrix_to_test)
    
    # First 6 values control L/R (rows 1-6)
    # Last 6 values control M (rows 1-6)
    LR_adjustments <- align_vec[1:6]
    M_adjustments <- align_vec[7:12]
    
    # Apply to the data based on Row and Space
    data_adjusted <- data %>%
        mutate(
            adjustment = case_when(
                Space %in% c("L", "R") ~ LR_adjustments[Row],
                Space == "M" ~ M_adjustments[Row]
            ),
            Side_new = wrap_around(Side + adjustment - 1)
        )
    
    data_adjusted %>%
        group_by(Side_new, Space) %>%
        summarize(column_sum = sum(Value), .groups = 'drop') %>%
        return()
}

side_sums()

L_R_test_sums <- function(side_sums_result = side_sums()){
    L_R_Test <- side_sums_result %>%
        filter(Space %in% c("L","R")) %>%
        rowwise() %>%
        mutate(sides = (column_sum == 30))

    return(L_R_Test)

}

L_R_test_sums()

M_test_sums <- function(side_sums_result = side_sums()){
    M_Test <- side_sums_result %>%
        filter(Space %in% c("M")) %>%
        rowwise() %>%
        mutate(sides = (column_sum == 31))

    return(M_Test)
}

M_test_sums()

configuration_test <- function(alignment_matrix_to_test = c(rep(1, 6), rep(1, 6)), data = tower_data){
    side_sums_result <- side_sums(alignment_matrix_to_test = alignment_matrix_to_test, data = data)

    L_R_result <- L_R_test_sums(side_sums_result = side_sums_result)

    M_result <- M_test_sums(side_sums_result = side_sums_result)

    combined_result <- side_sums_result %>%
        left_join(L_R_result,by = c("Side_new","Space","column_sum")) %>%
        left_join(M_result,by = c("Side_new","Space","column_sum")) %>%
        mutate(sides = coalesce(sides.x, sides.y)) %>%
        select(-sides.x, -sides.y)

    return(combined_result)

}





```

This will cycle through the whole universe of possible alignments (4\^6)

```{r}
# Test only L/R alignments
LR_alignment_matrix <- expand.grid(
  R1_LR = 1:4, R2_LR = 1:4, R3_LR = 1:4, 
  R4_LR = 1:4, R5_LR = 1:4, R6_LR = 1:4
)

side_sums_LR <- function(LR_alignment, data = tower_data){
    LR_vec <- unlist(LR_alignment)
    
    data %>%
        filter(Space %in% c("L", "R")) %>%
        mutate(
            adjustment = LR_vec[Row],
            Side_new = wrap_around(Side + adjustment - 1)
        ) %>%
        group_by(Side_new, Space) %>%
        summarize(column_sum = sum(Value), .groups = 'drop') %>%
        return()
}

test_LR <- function(LR_alignment){
    sums <- side_sums_LR(LR_alignment)
    return(sum(sums$column_sum == 30))  # Count how many equal 30
}

LR_results <- LR_alignment_matrix %>%
    rowwise() %>%
    mutate(LR_score = test_LR(c_across(1:6))) %>%
    ungroup()

good_LR <- LR_results %>% filter(LR_score == 8)  # All 8 L/R columns = 30
```


```{r}
M_alignment_matrix <- expand.grid(
  R1_M = 1:4, R2_M = 1:4, R3_M = 1:4, 
  R4_M = 1:4, R5_M = 1:4, R6_M = 1:4
)

side_sums_M <- function(M_alignment, data = tower_data){
    M_vec <- unlist(M_alignment)
    
    data %>%
        filter(Space == "M") %>%
        mutate(
            adjustment = M_vec[Row],
            Side_new = wrap_around(Side + adjustment - 1)
        ) %>%
        group_by(Side_new, Space) %>%
        summarize(column_sum = sum(Value), .groups = 'drop') %>%
        return()
}

test_M <- function(M_alignment){
    sums <- side_sums_M(M_alignment)
    return(sum(sums$column_sum == 31))  # Count how many equal 31
}

M_results <- M_alignment_matrix %>%
    rowwise() %>%
    mutate(M_score = test_M(c_across(1:6))) %>%
    ungroup()

good_M <- M_results %>% filter(M_score == 4)  # All 4 M columns = 31
```

```{r}
perfect_solutions <- crossing(good_LR, good_M) %>%
    select(R1_LR:R6_LR, R1_M:R6_M, LR_score, M_score)
```



So now that we've got all the results, let's find the ones that have the most good columns (that is, 30 in the left and right and 31 in the center)

```{r}
good_configuration_test <- function(test_results){
    good_configuration_val <- sum(test_results$sides, na.rm = FALSE)
    return(good_configuration_val)
}

#good_configuration_test()

results_df2 <- results_df %>%
    rowwise() %>%
    mutate(test = good_configuration_test(configuration_test_results)) %>%
    ungroup()

good_configurations <- results_df2 %>%
    arrange(desc(test)) %>%
    print()
```

OK, so we've found some that work (probably)!

Let's use the initial data function to figure out how to set up the pyramid, and then print up the recipe.

```{r}

good_alignment <-  good_configurations %>% select(1:6) %>% head(1)

configuration_test(good_alignment)

pyramid_builder <- function(alignment_matrix_that_works = good_alignment, data = tower_data){

  # Match the logic from side_sums() exactly
    alignment_adjustment <- rep(unlist(alignment_matrix_that_works), each = 3)
    
    data$Side_new <- wrap_around(data$Side + alignment_adjustment - 1)
    
    data %>%
        arrange(Side_new, Row) %>%
        return()

}

pyramid_builder(alignment_matrix_that_works = good_configurations %>% select(1:6) %>% head(1)) %>%
   # filter(Space == "L") %>%
    #head(6) %>%
    #summarize(sum(Value)) %>%
    print(n=18)
```