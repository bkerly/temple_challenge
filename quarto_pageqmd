---
title: "Temple Tower Project"
format: html
---

First I'm going to load some packages. Tidyverse has most of the functions I use for msot data analysis, plus a bunch of packages I probably won't use but it's fine for now.

```{r}
library("tidyverse")
library("readr")
```

Now I'm going to load in the data for the tower. This is in the below format.

```{r}
tower_data <- read_csv("tower_data.csv") 
head(tower_data,20)
sides <- 1:4
rows <- 1:6
space <- tower_data$Space %>% unique()
```

Let's add a check that the whole tower adds to 365 like its supposed to

```{r}
sum(tower_data$Value) %>%
    print()
```

Next I'm going to make a few functions to help analyze the tower data. The first one is a helper function called "wrap around" which helps so that if I rotate a level of the tower past side 4 it is on side 1, rather than a mythical side 5.

```{r}

wrap_around <- wrap_around <- function(x) {
  ifelse(x > 4, x - 4, x)
}

```

The next few functions are for getting the sums of each column in a given configuration. The alignment of the tower is given as the "alignment matrix". The first function will rotate the tower to match a given alignment and sum up each row. Then there are tests to check if the left and right columns sum to 30 and the middle column sums to 31.

Finally, a big "configuration test" function will combine all those and spit out a single dataframe.

```{r}

side_sums <- function(alignment_matrix_to_test = rep(1, 12), data = tower_data){
    
    # Convert to vector if needed
    align_vec <- unlist(alignment_matrix_to_test)
    
    # Create adjustment: LR values go to positions 1,3,5,7,9,11,13,15,17
    #                     M values go to positions 2,6,10,14,18
    alignment_adjustment <- numeric(18)
    alignment_adjustment[c(1,3,5,7,9,11,13,15,17)] <- align_vec[c(1,3,5,7,9,11)]  # L and R
    alignment_adjustment[c(2,6,10,14,18)] <- align_vec[c(2,4,6,8,10,12)]  # M
    
    data %>%
        mutate(Side_new = wrap_around(Side + alignment_adjustment - 1)) %>%
        group_by(Side_new, Space) %>%
        summarize(column_sum = sum(Value), .groups = 'drop') %>%
        return()
}

side_sums()

L_R_test_sums <- function(side_sums_result = side_sums()){
    L_R_Test <- side_sums_result %>%
        filter(Space %in% c("L","R")) %>%
        rowwise() %>%
        mutate(sides = (column_sum == 30))

    return(L_R_Test)

}

L_R_test_sums()

M_test_sums <- function(side_sums_result = side_sums()){
    M_Test <- side_sums_result %>%
        filter(Space %in% c("M")) %>%
        rowwise() %>%
        mutate(sides = (column_sum == 31))

    return(M_Test)
}

M_test_sums()

configuration_test <- function(alignment_matrix_to_test = c(1,2,3,4,2,1), data = tower_data){
    side_sums_result <- side_sums(alignment_matrix_to_test = alignment_matrix_to_test, data = data)

    L_R_result <- L_R_test_sums(side_sums_result = side_sums_result)

    M_result <- M_test_sums(side_sums_result = side_sums_result)

    combined_result <- side_sums_result %>%
        left_join(L_R_result,by = c("Side_new","Space","column_sum")) %>%
        left_join(M_result,by = c("Side_new","Space","column_sum")) %>%
        mutate(sides = coalesce(sides.x, sides.y)) %>%
        select(-sides.x, -sides.y)

    return(combined_result)

}

configuration_test(c(1,2,3,4,2,1))

configuration_test(c(1,2,3,2,2,1))




```

This will cycle through the whole universe of possible alignments (4\^6)

```{r}
alignment_matrix_expanded <- expand.grid(
  V1 = 1:4,
  V2 = 1:4,
  V3 = 1:4,
  V4 = 1:4,
  V5 = 1:4,
  V6 = 1:4
)

results_df <- alignment_matrix_expanded %>%
    mutate(configuration_test_results = NA) %>%
    as_tibble()

for(i in 1:nrow(alignment_matrix_expanded)) {
    test_alignment <- alignment_matrix_expanded %>% slice(i)
    configuration_test_results <- configuration_test(alignment_matrix_to_test = test_alignment) %>% data.frame()
    results_df$configuration_test_results[i] <- list(configuration_test_results)
    
    if(i %% 10000 == 0) {
        print(paste0("Calculating row ", i, " of ", nrow(alignment_matrix_expanded)))
    }
}

head(results_df)

results_df$configuration_test_results[7]

results_df$configuration_test_results[42]
```

So now that we've got all the results, let's find the ones that have the most good columns (that is, 30 in the left and right and 31 in the center)

```{r}
good_configuration_test <- function(test_results){
    good_configuration_val <- sum(test_results$sides, na.rm = FALSE)
    return(good_configuration_val)
}

#good_configuration_test()

results_df2 <- results_df %>%
    rowwise() %>%
    mutate(test = good_configuration_test(configuration_test_results)) %>%
    ungroup()

good_configurations <- results_df2 %>%
    arrange(desc(test)) %>%
    print()
```

OK, so we've found some that work (probably)!

Let's use the initial data function to figure out how to set up the pyramid, and then print up the recipe.

```{r}

good_alignment <-  good_configurations %>% select(1:6) %>% head(1)

configuration_test(good_alignment)

pyramid_builder <- function(alignment_matrix_that_works = good_alignment, data = tower_data){

  # Match the logic from side_sums() exactly
    alignment_adjustment <- rep(unlist(alignment_matrix_that_works), each = 3)
    
    data$Side_new <- wrap_around(data$Side + alignment_adjustment - 1)
    
    data %>%
        arrange(Side_new, Row) %>%
        return()

}

pyramid_builder(alignment_matrix_that_works = good_configurations %>% select(1:6) %>% head(1)) %>%
   # filter(Space == "L") %>%
    #head(6) %>%
    #summarize(sum(Value)) %>%
    print(n=18)
```